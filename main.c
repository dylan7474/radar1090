#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <pthread.h>

#include <SDL.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>
#include <curl/curl.h>
#include <jansson.h>

#include "config.h"

// This header is generated by running `xxd -i <your_font_file.ttf> > font_data.h`
#include "font_data.h"

// --- Font Data Configuration ---
// The `xxd -i` command creates variable names based on the input filename.
// For example, if your font file is named `my_font.ttf`, the variables in
// font_data.h will be `my_font_ttf` and `my_font_ttf_len`.
//
// **ACTION**: These macros have been updated to match your 'PressStart2P-Regular.ttf' file.
#define EMBEDDED_FONT_ARRAY PressStart2P_Regular_ttf
#define EMBEDDED_FONT_LEN   PressStart2P_Regular_ttf_len


#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// --- Display & Timing Constants ---
#define SCREEN_WIDTH 800
#define SCREEN_HEIGHT 600
#define REFRESH_INTERVAL_MS 5000
#define DISPLAY_TIMEOUT_MS 1500

// --- Radar Constants ---
#define EARTH_RADIUS_KM 6371.0
#define BLIP_LIFESPAN_MS 10000 // Blips last for 10 seconds
#define RADAR_CENTER_X (SCREEN_WIDTH * 0.7)
#define RADAR_CENTER_Y (SCREEN_HEIGHT / 2)
#define RADAR_RADIUS (SCREEN_HEIGHT * 0.4)

// --- Audio Constants ---
#define AUDIO_FREQ 44100
#define AUDIO_SAMPLES 2048
#define ALT_LOW_FEET 10000
#define ALT_HIGH_FEET 30000
#define FREQ_LOW 800
#define FREQ_MID 1200
#define FREQ_HIGH 1800

// --- Data Structs ---
typedef struct {
    char flight[10];
    double distanceKm;
    double bearing;
    int altitude;
    float groundSpeed;
    bool isValid;
} Aircraft;

typedef struct {
    int x;
    int y;
    Uint32 spawnTime;
    double bearing;
} RadarBlip;

// --- Control State ---
typedef enum { VOLUME, SPEED } ControlMode;
ControlMode currentMode = VOLUME;

// --- Global State Variables ---
bool app_is_running = true;
bool dataConnectionOk = false;
Aircraft lastPingedAircraft = { .isValid = false };
Aircraft* trackedAircraft = NULL;
int trackedAircraftCount = 0;
RadarBlip* activeBlips = NULL;
int activeBlipsCount = 0;
pthread_mutex_t dataMutex;

// --- Control & Display Variables ---
int beepVolume = 10; // 0-20
float rangeSteps[] = {5, 10, 25, 50, 100, 150, 200, 300};
const int rangeStepsCount = sizeof(rangeSteps) / sizeof(rangeSteps[0]);
int rangeStepIndex = 3;
float radarRangeKm;
float sweepSpeedSteps[] = {90.0, 180.0, 270.0, 360.0};
const int speedStepsCount = sizeof(sweepSpeedSteps) / sizeof(sweepSpeedSteps[0]);
int sweepSpeedIndex = 1;
float sweepSpeed;
Uint32 displayTimeout = 0;
char displayMessage[100];

// --- Animation & Audio State ---
float sweepAngle = 0.0;
float lastSweepAngle = 0.0;
bool* paintedThisTurn = NULL;
int beep_freq = 0;
int beep_duration_ms = 0;
volatile int beep_samples_left = 0;

// --- Function Prototypes ---
double deg2rad(double deg);
double haversine(double lat1, double lon1, double lat2, double lon2);
double calculateBearing(double lat1, double lon1, double lat2, double lon2);
void drawText(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y, SDL_Color color, bool center);
void drawDottedCircle(SDL_Renderer *renderer, int32_t centreX, int32_t centreY, int32_t radius);
void SDL_RenderDrawCircle(SDL_Renderer * renderer, int32_t centreX, int32_t centreY, int32_t radius);
void drawPlaneIcon(SDL_Renderer* renderer, int x, int y, double bearing);

// --- Networking ---
struct MemoryStruct { char *memory; size_t size; };

static size_t WriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp) {
    size_t realsize = size * nmemb;
    struct MemoryStruct *mem = (struct MemoryStruct *)userp;
    char *ptr = realloc(mem->memory, mem->size + realsize + 1);
    if(!ptr) { printf("not enough memory (realloc returned NULL)\n"); return 0; }
    mem->memory = ptr;
    memcpy(&(mem->memory[mem->size]), contents, realsize);
    mem->size += realsize;
    mem->memory[mem->size] = 0;
    return realsize;
}

void* fetchDataTask(void *arg) {
    CURLcode res;
    struct MemoryStruct chunk;
    char url[200];
    snprintf(url, sizeof(url), "http://%s:%d/dump1090-fa/data/aircraft.json", DUMP1090_SERVER, DUMP1090_PORT);

    curl_global_init(CURL_GLOBAL_ALL);
    CURL *curl_handle = curl_easy_init();
    if (!curl_handle) {
        fprintf(stderr, "curl_easy_init() failed\n");
        curl_global_cleanup();
        return NULL;
    }

    curl_easy_setopt(curl_handle, CURLOPT_URL, url);
    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);
    curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, "libcurl-agent/1.0");
    curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT_MS, 4000L);

    while(app_is_running) {
        chunk.memory = malloc(1);
        if (!chunk.memory) {
            fprintf(stderr, "Failed to allocate memory for CURL buffer\n");
            SDL_Delay(REFRESH_INTERVAL_MS);
            continue;
        }
        chunk.size = 0;
        curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&chunk);
        res = curl_easy_perform(curl_handle);

        if(res == CURLE_OK) {
            json_error_t error;
            json_t *root = json_loads(chunk.memory, 0, &error);
            if (root) {
                dataConnectionOk = true;
                json_t *aircraft_array = json_object_get(root, "aircraft");
                if (json_is_array(aircraft_array)) {
                    size_t count = json_array_size(aircraft_array);
                    Aircraft* planesInRange = malloc(sizeof(Aircraft) * (count > 0 ? count : 1));
                    if (planesInRange) {
                        int planesInRangeCount = 0;

                        for (size_t i = 0; i < count; i++) {
                        json_t *plane = json_array_get(aircraft_array, i);
                        json_t *lat_json = json_object_get(plane, "lat");
                        json_t *lon_json = json_object_get(plane, "lon");

                        if (json_is_real(lat_json) && json_is_real(lon_json)) {
                            double dist = haversine(USER_LAT, USER_LON, json_real_value(lat_json), json_real_value(lon_json));
                            if (dist < radarRangeKm) {
                                Aircraft ac = {.isValid = true};
                                const char* flightStr = json_string_value(json_object_get(plane, "flight"));
                                if(flightStr) { strncpy(ac.flight, flightStr, sizeof(ac.flight) - 1); ac.flight[sizeof(ac.flight) - 1] = '\0'; } else { ac.flight[0] = '\0'; }

                                ac.distanceKm = dist;
                                ac.bearing = calculateBearing(USER_LAT, USER_LON, json_real_value(lat_json), json_real_value(lon_json));

                                json_t *alt_json = json_object_get(plane, "alt_baro");
                                if (json_is_integer(alt_json)) ac.altitude = json_integer_value(alt_json); else ac.altitude = -1;

                                json_t *gs_json = json_object_get(plane, "gs");
                                if(json_is_real(gs_json)) ac.groundSpeed = json_real_value(gs_json); else ac.groundSpeed = -1.0f;

                                planesInRange[planesInRangeCount++] = ac;
                            }
                        }
                    }
                    pthread_mutex_lock(&dataMutex);
                    free(trackedAircraft);
                    trackedAircraft = planesInRange;
                    trackedAircraftCount = planesInRangeCount;
                    // New data arrived, so we need a new paint buffer
                        free(paintedThisTurn);
                        paintedThisTurn = calloc(trackedAircraftCount > 0 ? trackedAircraftCount : 1, sizeof(bool));
                        if (!paintedThisTurn) {
                            dataConnectionOk = false;
                        }
                        pthread_mutex_unlock(&dataMutex);
                    } else {
                        dataConnectionOk = false;
                    }
                }
                json_decref(root);
            } else {
                dataConnectionOk = false;
            }
        } else {
            fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
            dataConnectionOk = false;
            pthread_mutex_lock(&dataMutex);
            trackedAircraftCount = 0;
            lastPingedAircraft.isValid = false;
            pthread_mutex_unlock(&dataMutex);
        }

        free(chunk.memory);
        SDL_Delay(REFRESH_INTERVAL_MS);
    }
    curl_easy_cleanup(curl_handle);
    curl_global_cleanup();
    return NULL;
}

// --- Audio ---
void audio_callback(void *userdata, Uint8 *stream, int len) {
    Sint16 *buffer = (Sint16*)stream;
    int length = len / 2; // 16-bit samples
    static double phase = 0.0;
    
    int samples_to_process = (beep_samples_left < length) ? beep_samples_left : length;
    
    if (samples_to_process > 0) {
        double phase_step = 2.0 * M_PI * beep_freq / AUDIO_FREQ;
        Sint16 amplitude = (Sint16)(3000 * (beepVolume / 20.0));
        for (int i = 0; i < samples_to_process; i++) {
            buffer[i] = (Sint16)(amplitude * sin(phase));
            phase += phase_step;
        }
        beep_samples_left -= samples_to_process;
    }
    
    if (samples_to_process < length) {
        SDL_memset(buffer + samples_to_process, 0, (length - samples_to_process) * sizeof(Sint16));
    }
}

void playBeep(int freq, int duration_ms) {
    if (beep_samples_left > 0) return;
    beep_freq = freq;
    beep_duration_ms = duration_ms;
    SDL_LockAudio();
    beep_samples_left = (int)((AUDIO_FREQ / 1000.0) * duration_ms);
    SDL_UnlockAudio();
}

int getBeepFrequencyForAltitude(int altitude) {
    if (altitude < 0) return FREQ_MID;
    if (altitude < ALT_LOW_FEET) return FREQ_LOW;
    else if (altitude < ALT_HIGH_FEET) return FREQ_MID;
    else return FREQ_HIGH;
}


// --- Main Application ---
int main(int argc, char* argv[]) {
    if (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO) != 0) {
        fprintf(stderr, "SDL_Init Error: %s\n", SDL_GetError());
        return 1;
    }
    if (TTF_Init() == -1) {
        fprintf(stderr, "TTF_Init Error: %s\n", TTF_GetError());
        SDL_Quit();
        return 1;
    }

    SDL_Window* window = SDL_CreateWindow("Closest Plane Radar", SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, SCREEN_WIDTH, SCREEN_HEIGHT, 0);
    if (!window) {
        fprintf(stderr, "SDL_CreateWindow Error: %s\n", SDL_GetError());
        TTF_Quit(); SDL_Quit(); return 1;
    }
    SDL_Renderer* renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);
     if (!renderer) {
        fprintf(stderr, "SDL_CreateRenderer Error: %s\n", SDL_GetError());
        SDL_DestroyWindow(window); TTF_Quit(); SDL_Quit(); return 1;
    }

    // Use the macros defined at the top of the file to load the font from memory.
    // This makes it easy to change the font file without editing code logic.
    SDL_RWops* font_mem = SDL_RWFromConstMem(EMBEDDED_FONT_ARRAY, EMBEDDED_FONT_LEN);
    TTF_Font* font = TTF_OpenFontRW(font_mem, 1, 24);
    if (!font) { fprintf(stderr, "Failed to load main font: %s\n", TTF_GetError()); /* continue anyway */ }
    
    // The RWops needs to be created again for the second font load.
    SDL_RWops* small_font_mem = SDL_RWFromConstMem(EMBEDDED_FONT_ARRAY, EMBEDDED_FONT_LEN);
    TTF_Font* small_font = TTF_OpenFontRW(small_font_mem, 1, 18);
    if (!small_font) { fprintf(stderr, "Failed to load small font: %s\n", TTF_GetError()); /* continue anyway */ }


    SDL_AudioSpec want, have;
    SDL_memset(&want, 0, sizeof(want));
    want.freq = AUDIO_FREQ;
    want.format = AUDIO_S16SYS;
    want.channels = 1;
    want.samples = AUDIO_SAMPLES;
    want.callback = audio_callback;
    if (SDL_OpenAudio(&want, &have) < 0) {
        fprintf(stderr, "Failed to open audio: %s\n", SDL_GetError());
    } else {
        SDL_PauseAudio(0);
    }

    pthread_t network_thread;
    pthread_mutex_init(&dataMutex, NULL);
    pthread_create(&network_thread, NULL, fetchDataTask, NULL);

    radarRangeKm = rangeSteps[rangeStepIndex];
    sweepSpeed = sweepSpeedSteps[sweepSpeedIndex];
    
    Uint32 lastFrameTime = SDL_GetTicks();

    // Main Loop
    while (app_is_running) {
        Uint32 currentTime = SDL_GetTicks();
        float deltaTime = (currentTime - lastFrameTime) / 1000.0f;
        lastFrameTime = currentTime;

        // Event Handling
        SDL_Event event;
        while (SDL_PollEvent(&event)) {
            if (event.type == SDL_QUIT) {
                app_is_running = false;
            }
            if (event.type == SDL_KEYDOWN) {
                switch (event.key.keysym.sym) {
                    case SDLK_q: app_is_running = false; break;
                    case SDLK_m: 
                        currentMode = (currentMode == VOLUME) ? SPEED : VOLUME;
                        snprintf(displayMessage, sizeof(displayMessage), "Mode: %s", currentMode == VOLUME ? "Volume" : "Sweep Speed");
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_EQUALS:
                    case SDLK_PLUS:
                        if (currentMode == VOLUME) {
                            if (beepVolume < 20) beepVolume++;
                            snprintf(displayMessage, sizeof(displayMessage), "Volume: %d", beepVolume);
                        } else {
                            if (sweepSpeedIndex < speedStepsCount - 1) sweepSpeedIndex++;
                            sweepSpeed = sweepSpeedSteps[sweepSpeedIndex];
                            snprintf(displayMessage, sizeof(displayMessage), "Speed: %.0f d/s", sweepSpeed);
                        }
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_MINUS:
                        if (currentMode == VOLUME) {
                            if (beepVolume > 0) beepVolume--;
                            snprintf(displayMessage, sizeof(displayMessage), "Volume: %d", beepVolume);
                        } else {
                            if (sweepSpeedIndex > 0) sweepSpeedIndex--;
                            sweepSpeed = sweepSpeedSteps[sweepSpeedIndex];
                            snprintf(displayMessage, sizeof(displayMessage), "Speed: %.0f d/s", sweepSpeed);
                        }
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_UP:
                        if(rangeStepIndex < rangeStepsCount - 1) rangeStepIndex++;
                        radarRangeKm = rangeSteps[rangeStepIndex];
                        snprintf(displayMessage, sizeof(displayMessage), "Range: %.0f km", radarRangeKm);
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                    case SDLK_DOWN:
                        if(rangeStepIndex > 0) rangeStepIndex--;
                        radarRangeKm = rangeSteps[rangeStepIndex];
                        snprintf(displayMessage, sizeof(displayMessage), "Range: %.0f km", radarRangeKm);
                        displayTimeout = currentTime + DISPLAY_TIMEOUT_MS;
                        break;
                }
            }
        }

        // Update
        lastSweepAngle = sweepAngle;
        sweepAngle += sweepSpeed * deltaTime;
        bool sweepWrapped = false;
        if (sweepAngle >= 360.0f) {
            sweepAngle = fmod(sweepAngle, 360.0f);
            sweepWrapped = true;
        }

        pthread_mutex_lock(&dataMutex);
        if (sweepWrapped && paintedThisTurn) {
             memset(paintedThisTurn, 0, trackedAircraftCount * sizeof(bool));
        }

        for (int i = 0; i < trackedAircraftCount; i++) {
            if(paintedThisTurn && !paintedThisTurn[i]) {
                double targetBearing = trackedAircraft[i].bearing;
                bool bearingCrossed = (lastSweepAngle < targetBearing && sweepAngle >= targetBearing) ||
                                      (sweepWrapped && (targetBearing > lastSweepAngle || targetBearing <= sweepAngle));

                if(bearingCrossed) {
                    double angleRad = deg2rad(targetBearing);
                    float screenRadius = (trackedAircraft[i].distanceKm / radarRangeKm) * RADAR_RADIUS;
                    
                    RadarBlip* newBlips = realloc(activeBlips, (activeBlipsCount + 1) * sizeof(RadarBlip));
                    if (newBlips) {
                        activeBlips = newBlips;
                        activeBlips[activeBlipsCount].x = RADAR_CENTER_X + screenRadius * sin(angleRad);
                        activeBlips[activeBlipsCount].y = RADAR_CENTER_Y - screenRadius * cos(angleRad);
                        activeBlips[activeBlipsCount].spawnTime = currentTime;
                        activeBlips[activeBlipsCount].bearing = targetBearing;
                        activeBlipsCount++;

                        lastPingedAircraft = trackedAircraft[i];
                        paintedThisTurn[i] = true;
                        playBeep(getBeepFrequencyForAltitude(trackedAircraft[i].altitude), 50);
                    }
                }
            }
        }
        pthread_mutex_unlock(&dataMutex);

        // Update blips (in-place filtering)
        int aliveBlips = 0;
        for (int i = 0; i < activeBlipsCount; i++) {
            if (currentTime - activeBlips[i].spawnTime < BLIP_LIFESPAN_MS) {
                if (i != aliveBlips) {
                    activeBlips[aliveBlips] = activeBlips[i];
                }
                aliveBlips++;
            }
        }
        activeBlipsCount = aliveBlips;


        // Render
        SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
        SDL_RenderClear(renderer);

        // UI Text
        char buffer[100];
        int text_y = 20;
        SDL_Color white = {255, 255, 255, 255};
        SDL_Color green = {0, 255, 0, 255};
        SDL_Color red = {255, 0, 0, 255};

        if (lastPingedAircraft.isValid) {
            snprintf(buffer, sizeof(buffer), "Flt: %s", strlen(lastPingedAircraft.flight) > 0 ? lastPingedAircraft.flight : "------");
            drawText(renderer, font, buffer, 20, text_y, white, false); text_y += 35;
            snprintf(buffer, sizeof(buffer), "Dst: %.1f km", lastPingedAircraft.distanceKm);
            drawText(renderer, font, buffer, 20, text_y, white, false); text_y += 35;
            if (lastPingedAircraft.altitude > 0) snprintf(buffer, sizeof(buffer), "Alt: %d ft", lastPingedAircraft.altitude);
            else snprintf(buffer, sizeof(buffer), "Alt: -----");
            drawText(renderer, font, buffer, 20, text_y, white, false); text_y += 35;
            if (lastPingedAircraft.groundSpeed > 0) snprintf(buffer, sizeof(buffer), "Spd: %.0f kt", lastPingedAircraft.groundSpeed);
            else snprintf(buffer, sizeof(buffer), "Spd: ---");
            drawText(renderer, font, buffer, 20, text_y, white, false); text_y += 35;
        } else {
             drawText(renderer, font, "Scanning...", 20, text_y, white, false); text_y += 35;
        }
        
        text_y = SCREEN_HEIGHT - 120;
        snprintf(buffer, sizeof(buffer), "Range: %.0f km", radarRangeKm);
        drawText(renderer, font, buffer, 20, text_y, green, false); text_y += 35;
        snprintf(buffer, sizeof(buffer), "Tracked: %d", trackedAircraftCount);
        drawText(renderer, font, buffer, 20, text_y, green, false); text_y += 35;
        drawText(renderer, font, dataConnectionOk ? "Link: OK" : "Link: DOWN", 20, text_y, dataConnectionOk ? green : red, false);

        // Radar Display
        SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
        for(int w = 0; w < 3; w++) {
            SDL_RenderDrawCircle(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, RADAR_RADIUS - w);
        }
        drawDottedCircle(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, RADAR_RADIUS * 2 / 3);
        drawDottedCircle(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, RADAR_RADIUS * 1 / 3);
        drawText(renderer, small_font, "N", RADAR_CENTER_X, RADAR_CENTER_Y - RADAR_RADIUS - 10, green, true);

        // Radar Sweep
        double sweepRad = deg2rad(sweepAngle);
        SDL_RenderDrawLine(renderer, RADAR_CENTER_X, RADAR_CENTER_Y, 
            RADAR_CENTER_X + (RADAR_RADIUS - 2) * sin(sweepRad), 
            RADAR_CENTER_Y - (RADAR_RADIUS - 2) * cos(sweepRad));

        // Blips
        for (int i = 0; i < activeBlipsCount; i++) {
            drawPlaneIcon(renderer, activeBlips[i].x, activeBlips[i].y, activeBlips[i].bearing);
        }

        // Display Overlay
        if (currentTime < displayTimeout) {
            SDL_Rect bg = {SCREEN_WIDTH/2 - 175, SCREEN_HEIGHT/2 - 40, 350, 80};
            SDL_SetRenderDrawBlendMode(renderer, SDL_BLENDMODE_BLEND);
            SDL_SetRenderDrawColor(renderer, 0, 0, 50, 200);
            SDL_RenderFillRect(renderer, &bg);
            SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);
            SDL_RenderDrawRect(renderer, &bg);
            drawText(renderer, font, displayMessage, SCREEN_WIDTH/2, bg.y + 25, white, true);
        }

        SDL_RenderPresent(renderer);
    }

    // Cleanup
    app_is_running = false;
    pthread_join(network_thread, NULL);
    pthread_mutex_destroy(&dataMutex);
    
    free(trackedAircraft);
    free(activeBlips);
    free(paintedThisTurn);
    
    SDL_CloseAudio();
    if(font) TTF_CloseFont(font);
    if(small_font) TTF_CloseFont(small_font);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    TTF_Quit();
    SDL_Quit();

    return 0;
}

// Helper function to draw an unfilled circle using Bresenham's algorithm
void SDL_RenderDrawCircle(SDL_Renderer * renderer, int32_t centreX, int32_t centreY, int32_t radius) {
   const int32_t diameter = (radius * 2);
   int32_t x = (radius - 1);
   int32_t y = 0;
   int32_t tx = 1;
   int32_t ty = 1;
   int32_t error = (tx - diameter);
   while (x >= y) {
      SDL_RenderDrawPoint(renderer, centreX + x, centreY - y);
      SDL_RenderDrawPoint(renderer, centreX + x, centreY + y);
      SDL_RenderDrawPoint(renderer, centreX - x, centreY - y);
      SDL_RenderDrawPoint(renderer, centreX - x, centreY + y);
      SDL_RenderDrawPoint(renderer, centreX + y, centreY - x);
      SDL_RenderDrawPoint(renderer, centreX + y, centreY + x);
      SDL_RenderDrawPoint(renderer, centreX - y, centreY - x);
      SDL_RenderDrawPoint(renderer, centreX - y, centreY + x);
      if (error <= 0) { ++y; error += ty; ty += 2; }
      if (error > 0) { --x; tx += 2; error += (tx - diameter); }
   }
}

void drawDottedCircle(SDL_Renderer *renderer, int32_t centreX, int32_t centreY, int32_t radius) {
    for (int i = 0; i < 360; i += 15) {
        double angleRad = deg2rad(i);
        int16_t x = centreX + radius * sin(angleRad);
        int16_t y = centreY - radius * cos(angleRad);
        SDL_RenderDrawPoint(renderer, x, y);
    }
}

void drawText(SDL_Renderer* renderer, TTF_Font* font, const char* text, int x, int y, SDL_Color color, bool center) {
    if (!text || !font) return;
    SDL_Surface* surface = TTF_RenderText_Blended(font, text, color);
    if (!surface) return;
    SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
    if (!texture) { SDL_FreeSurface(surface); return; }
    
    SDL_Rect destRect = {x, y, surface->w, surface->h};
    if (center) {
        destRect.x = x - surface->w / 2;
        destRect.y = y - surface->h / 2;
    }

    SDL_RenderCopy(renderer, texture, NULL, &destRect);
    SDL_FreeSurface(surface);
    SDL_DestroyTexture(texture);
}

void drawPlaneIcon(SDL_Renderer* renderer, int x, int y, double bearing) {
    double angle = deg2rad(bearing);
    double dx = sin(angle);
    double dy = -cos(angle);
    double px = -dy;
    double py = dx;

    const double bodyLen = 10.0;
    const double wingSpan = 6.0;

    SDL_Point nose = {
        x + (int)(dx * bodyLen / 2.0),
        y + (int)(dy * bodyLen / 2.0)
    };
    SDL_Point tail = {
        x - (int)(dx * bodyLen / 2.0),
        y - (int)(dy * bodyLen / 2.0)
    };
    SDL_RenderDrawLine(renderer, tail.x, tail.y, nose.x, nose.y);

    SDL_Point wingLeft = {
        x + (int)(px * wingSpan / 2.0),
        y + (int)(py * wingSpan / 2.0)
    };
    SDL_Point wingRight = {
        x - (int)(px * wingSpan / 2.0),
        y - (int)(py * wingSpan / 2.0)
    };
    SDL_RenderDrawLine(renderer, wingLeft.x, wingLeft.y, wingRight.x, wingRight.y);

    SDL_Point tailLeft = {
        tail.x + (int)(px * wingSpan / 4.0),
        tail.y + (int)(py * wingSpan / 4.0)
    };
    SDL_Point tailRight = {
        tail.x - (int)(px * wingSpan / 4.0),
        tail.y - (int)(py * wingSpan / 4.0)
    };
    SDL_RenderDrawLine(renderer, tailLeft.x, tailLeft.y, tailRight.x, tailRight.y);
}

double deg2rad(double deg) { return deg * M_PI / 180.0; }
double haversine(double lat1, double lon1, double lat2, double lon2) {
    double dLat = deg2rad(lat2 - lat1);
    double dLon = deg2rad(lon2 - lon1);
    double a = sin(dLat / 2) * sin(dLat / 2) + cos(deg2rad(lat1)) * cos(deg2rad(lat2)) * sin(dLon / 2) * sin(dLon / 2);
    double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    return EARTH_RADIUS_KM * c;
}
double calculateBearing(double lat1, double lon1, double lat2, double lon2) {
    double lonDiff = deg2rad(lon2 - lon1);
    lat1 = deg2rad(lat1); lat2 = deg2rad(lat2);
    double y = sin(lonDiff) * cos(lat2);
    double x = cos(lat1) * sin(lat2) - sin(lat1) * cos(lat2) * cos(lonDiff);
    double bearing = atan2(y, x);
    bearing = fmod((bearing * 180.0 / M_PI + 360.0), 360.0);
    return bearing;
}

